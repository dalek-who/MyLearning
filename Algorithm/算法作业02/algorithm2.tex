\documentclass{article} 
	\usepackage{fontspec,booktabs, xunicode, xltxtra,amsmath,amssymb,caption,colortbl,float,caption,algorithm,algpseudocode}
	\usepackage{graphicx}
	\usepackage{pgfplots}
	\usepackage{xeCJK}
	\setCJKmainfont{MSYH.ttc}
	\author{孔静—2014K8009929022}
	\title{Algorithm-homework2}

\begin{document}   
	\maketitle
	\tableofcontents
	\section{Largest Divisible Subset}
		\paragraph{a}\
		
			考虑从小到大排列的数，不妨设a<b<c,若b能整除c，a能整除b，那么由于传递性，a也能整除c。在整除关系传递性的基础上，考虑最长整除序列，就可以类比算法研讨课上最长递增序列一样。所以我们第一步排序；第二步考虑$S_i$，在前面已经有了i-1个数，对每一个满足j<i的$Opt(j)$，若$s_i\%s_j=0$满足，则可以将其增加在$s_j$所在整除序列上，因此：
			\\
			\[O{\rm{pt}}(i) = \max \{ f(1),f(2),f(3),.....f(i - 1){\rm{\} }}\] 
			\\其中\[f(i) = \left\{ {\begin{array}{*{20}{l}}{1,\quad 0 \le j < i\quad {s_i}\% {s_j} \ne 0}\\{Opt(j) + 1,\quad 0 \le j < i\quad {s_i}\% {s_j} = 0}\end{array}} \right.\]
			
		\paragraph{b}\
		
			即利用上述公式对数据先排序后遍历，由于需要输出该序列，我设了两个参量，Opt[i][1]来记录当前序列长度。Opt[i][2]来记录他的当前最大序列的上一个数。
		\newpage
		\begin{algorithm}
		\caption{Find The Largest Divisible Subset}
		\begin{algorithmic}
		\Procedure {search}{n}
		\State quicksort(S)  *快速排序*
		\State i = 1
		\For {i <= n}
		\State j = 1
		\State Opt[i][1] = 1
		\For {j < i}
		\If { S[i] \% S[j] == 0}
		\If {Opt[i][0] < Opt[j][0] + 1}
		\State Opt[i][1] = Opt[j][0] + 1
		\State Opt[i][2] = S[j]
		\EndIf
		\EndIf
		\State m = max(Opt) *找到令Opt[i][1]最大的i*
		\State j = j + 1
		\EndFor
		\State i = i + 1
		\EndFor
		\State printsubset(m) *利用[2]存的数据及传递性输出该最长序列*
		\EndProcedure
		\end{algorithmic}
		\end{algorithm}
		
		\paragraph{c}\
			
			显然正确，首先已经从小到大排序好，对于i>j，若${s_i}$能被${s_j}$整除，那么也必然能被其他${s_j}$序列中的数整除，因为其他数比${s_j}$更小，利用整除的传递性，能寻找出最长序列。
			
		\paragraph{d}\
		
			快排O(nlogn)，遍历O($n^2$)，找到最大的数O(n)。
			
			综上算法复杂度是O($n^2$)。
	\newpage
	\section{Money Robbing}
		\paragraph{a}\
			
			不妨将房子编号，并将金额记为S[i]。
			\\
			
			\begin{tikzpicture}
				\draw[red, very thick] (0,4)rectangle(1,5);
				\node (1) at (0.5,4.5) {$S_1$};
				\draw[red, very thick] (1,4)rectangle(2,5);
				\node (2) at (1.5,4.5) {$...$};
				\draw[red, very thick] (2,4)rectangle(3,5);
				\node (3) at (2.5,4.5) {$S_{n-2}$};
				\draw[red, very thick] (3,4)rectangle(4,5);
				\node (4) at (3.5,4.5) {$S_{n-1}$};
				\draw[red, very thick] (4,4)rectangle(5,5);
				\node (5) at (4.5,4.5) {$S_n$};
				
				\draw[red, very thick] (-3,2)rectangle(-2,3);
				\node (a1) at (-2.5,2.5) {$S_1$};
				\draw[red, very thick] (-2,2)rectangle(-1,3);
				\node (a2) at (-1.5,2.5) {$...$};
				\draw[red, very thick] (-1,2)rectangle(0,3);
				\node (a3) at (-0.5,2.5) {$S_{n-2}$};
				\draw[red, very thick] (0,2)rectangle(1,3);
				\node (a4) at (0.5,2.5) {$S_{n-1}$};
				
				\draw[red, very thick] (2,2)rectangle(3,3);
				\node (b1) at (2.5,2.5) {$S_1$};
				\draw[red, very thick] (3,2)rectangle(4,3);
				\node (b2) at (3.5,2.5) {$...$};
				\draw[red, very thick] (4,2)rectangle(5,3);
				\node (b3) at (4.5,2.5) {$S_{n-2}$};
				\node (b4) at (5.5,2.5) {+};
				\draw[red, very thick] (6,2)rectangle(7,3);
				\node (5) at (6.5,2.5) {$S_n$};
				
				\draw[->] (2.5,4)--(-1,3.2);
				\draw[->] (2.5,4)--(4.5,3.2);	
			\end{tikzpicture}
			\[{\rm{Opt}}(i) = \max {\rm{\{ Opt(i - 1), Opt(i - 2)  +  }}{{\rm{S}}_i}{\rm{\} }}\]
			
		\paragraph{b}\
			\begin{algorithm}
				\caption{Money Robbing}
				\begin{algorithmic}
					\Procedure {MoreMoney}{n}
					\State Opt[1] = S[1]
					\State Opt[2] = max(S[1], S[2])
					\State i = 3
					\For {i <= n}
					\State Opt[i] = max(Opt[i-1], Opt[i-2] + S[i])
					\State i = i + 1
					\EndFor
					\State
					\Return <Opt[n]>
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
	
		\paragraph{c}\
		
			对于每个S[i]来说，只有被抢和没被抢两种情况，没被抢那么Opt[i] = Opt[i-1]，S[i]被抢，那么S[i-1]必然没被抢，所以Opt[i] = Opt[i-2] + S[i]。因此是这两种情况的最大值。
			
		\paragraph{d}\
		
			该程序只是进行一次大小比较，遍历即可，子问题O(1)，遍历O(n)。
		
			综上算法复杂度是O(n).
		\paragraph{circle}\
			
			删去任意一点，剩下部分仍可看作一条直线，区别在于n个点删去该点后，就只需要返回Opt[n-1]即可。但并不能确认哪个点可以被删去。不过任意2个连续的点必然有1个点不被选中可删去，所以可以在直线基础上，以任意2个连续的2个点为起点S[1]，返回Opt[n-1]，比较2个返回值，选择最大的即可。
			
			计算了2次直线情况，所以算法复杂度仍为O(n)。
	\section{Partition}
		\paragraph{a}\
		
		对于末尾字符S[i]，它与它前面字符可能形成多种情况的回文序列，形成回文后，即可切断扔掉，然后计算剩下的字符仍需要切几刀即可。
		\\
		
		\begin{tikzpicture}
		\draw[red, very thick] (0,4)rectangle(1,5);
		\node (1) at (0.5,4.5) {$S_1$};
		\draw[red, very thick] (1,4)rectangle(2,5);
		\node (2) at (1.5,4.5) {$S_2$};
		\draw[red, very thick] (2,4)rectangle(3,5);
		\node (3) at (2.5,4.5) {$...$};
		\draw[red, very thick] (3,4)rectangle(4,5);
		\node (4) at (3.5,4.5) {$S_{i-1}$};
		\draw[red, very thick] (4,4)rectangle(5,5);
		\node (5) at (4.5,4.5) {$S_i$};
		
		\draw[red, very thick] (-1,2)rectangle(0,3);
		\node (a1) at (-0.5,2.5) {$S_1$};
		\draw[red, very thick] (0,2)rectangle(1,3);
		\node (a2) at (0.5,2.5) {$...$};
		\draw[red, very thick] (1,2)rectangle(2,3);
		\node (a3) at (1.5,2.5) {$S_{j-1}$};
		
		\draw[red, very thick] (3,2)rectangle(4,3);
		\node (b1) at (3.5,2.5) {$S_{j}$};
		\draw[red, very thick] (4,2)rectangle(5,3);
		\node (b2) at (4.5,2.5) {$...$};
		\draw[red, very thick] (5,2)rectangle(6,3);
		\node (b3) at (5.5,2.5) {$S_{i}$};
		
		\draw[->] (2.5,4)--(0.5,3.2);
		\draw[->] (2.5,4)--(4.5,3.2);	
		\end{tikzpicture}
		
		\[{\rm{Opt}}(i) = {\max _{{\rm{j}} \in P}}{\rm{\{ Opt(j-1)  +  1\} }}\]
		\\其中，j满足条件：第j个字符到第i个字符为回文子序列
		
		\paragraph{b}\
			\begin{algorithm}
				\caption{Partition}
				\begin{algorithmic}
					\Procedure {Partition}{n}
					\State Opt[0] = -1 
					\State i = 2
					\For {i <= n}
					\State j = 1
					\For {j <= i}
					\If {judge(j,i)==1}  *判断S序列第j到i个字符是否是回文*
					\State Opt[i] = min(Opt[i], Opt[j - 1] + 1)
					\EndIf
					\EndFor
					\EndFor
					\State
					\Return <Opt[n]>
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\paragraph{c}\
		
		考虑字符S[i]，判断其与之前字符是否能成为回文，有至多i种情况，对每种情况进行遍历，选最小值，即是这i个字符的最小切分，遍历到n，即可得到最终结果。
		\paragraph{d}\
		
		子问题有O(n)，判断回文O(n)，遍历是O(n)。
		
		综上算法复杂度是O(${n^3}$).
		
	\newpage
	\section{Decoding}
		\paragraph{a}\
		
		对于末尾数字S[i]，它与S[i-1]如果可以组成一个编码是一种情况；它单独成一个编码也是一种情况。
		
		\[O{\rm{pt}}(i) = \left\{ {\begin{array}{*{20}{l}}
			{Opt(i - 1) + Opt(i - 2) , {S_{i - 1}}{S_i} \notin P}\\
			{Opt(i - 1) , {S_{i - 1}}{S_i} \in P}
			\end{array}} \right.\]
		\[{\rm{P = \{ }}1,2,3...26{\rm{\} }}\]
		
		
		\paragraph{b}\
		\begin{algorithm}
			\caption{Decoding}
			\begin{algorithmic}
				\Procedure {Partition}{n}
				\State Opt[0] = 0
				\State Opt[1] = 1
				\State i = 2
				\For {i <= n}
				\If { 27 > S[i-1] * 10 + S[i] > 0} 
				\State Opt[i] = Opt[i-1] + Opt[i-2]
				\Else
				\State Opt[i] = Opt[i-1]
				\EndIf
				\State i = i + 1
				\EndFor
				\State
				\Return <Opt[n]>
				\EndProcedure
			\end{algorithmic}
		\end{algorithm}
	
		\paragraph{c}\
		
			类比斐波那契数列，但与之不同的是，${S_{i - 1}}{S_i}$不一定有对应的字母，所以有两种情况，遍历一遍即可得到结果。
		\paragraph{d}\
		
		子问题有O(2)，遍历是O(n)。
		
		综上算法复杂度是O(n).
	
	\newpage
	\section{Minimum path sum}
			\paragraph{a}\
	
			在第i层，i个数据，每个数据向上至多2条路，即对每个数据来说有1~2种情况可以走。

\[O{\rm{pt}}[i][j] = \left\{ {\begin{array}{*{20}{l}}
	{num[i][j] + \min (Opt[i - 1][j - 1],Opt[i - 1][j]) , 1 < j < i}\\
	{num[i][j] + Opt[i - 1][1] , j = 0}\\
	{num[i][j] + Opt[i - 1][i - 1] , j = i}
	\end{array}} \right.\]
	\paragraph{b}\
	\begin{algorithm}
		\caption{Minimum path sum}
		\begin{algorithmic}
			\Procedure {Partition}{S,n}
			\State Opt[1] = 1
			\State i = 2
			\For {i <= n}
			\State Opt[i][1] = num[i][1] + Opt[i-1][1]
			\State Opt[i][i] = num[i][i] + Opt[i-1][i-1]
			\State j = 2
			\For {j <= i} 
			\State Opt[i][j] = num[i][j] + min(Opt[i-1][j], Opt[i-1][j+1])
			\State j = j + 1
			\EndFor
			\State i = i + 1
			\EndFor
			\State  answer = min{Opt , n} *对第n层n个结果找出最小值
			\Return <answer>
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\paragraph{c}\
	
	除了首末两个数据只有一条路可走，其他数据具有选择权利，然后对最后结果找出最小，即最终到达该层的最小值。
	\paragraph{d}\
	
	子问题有O(2)，遍历是O($n^2$)。
	
	综上算法复杂度是O($n^2$).
			
\end{document}