archlab_sopc_top.v
13行引入了新的输入作为键盘的按键输入
203~205行写入了中断，将按键的中断请求寄存器相应位置取或，并接到了中断路由的0位上
504行，批量给cr系列寄存器写了输入连线
510行，将键盘输入的线接到cr06_in上，形成输入，这里面0位取反是因为0位的寄存器连接复位处，该处低电平有效，平时一直维持高电平。


confreg.v
新加输入不多赘述
cr04为设置模式的标记位，1是设置模式，0不是
cr05为中断请求的寄存器
cr06为按键记录器

196行起到234行止，是防抖逻辑
两个temp寄存器逐次连接，再接到输入上，这样会记录下相邻两个周期的信号，我们对这两个值取异或，就说明信号在2个周期内变化了。
count寄存器作为计数器，正常而言每个周期+1，一直到相应时间20ms，才把按键寄存器写入相应的值。但是如果其在未达到20ms计数前，有抖动的话，就重新从0开始记录。

236行到 243行，设置寄存器控制逻辑
将cr04最低位的寄存器设计成 设置键信号 的上升沿触发，这样每次按设置键形成有效按键信号之后，就能够置位，每按一次取反。

246行到281行，写入逻辑
主要是对于cr05中断请求寄存器的控制逻辑
在每个周期到来的时候，cr05一般就跟随cr06按键控制的状态。

software change是标志位。
当侦测到没有按键的时候，software change保持0
当有按键之后，进入中断，写cr05（写1清0，因此采用^），表示软件清过中断。software change置位
当software change被置位的时候，cr05不再跟随按键状态，这样避免了重复中断。


start.s
60~63行	开头按要求开中断
185行修改lab1逻辑，每次循环显示过数字之后，会查询一下cr04设置模式寄存器，如果是设置模式，那么直接跳走，不会+1，这样表现为数字保持不动。

316行开始中断处理程序
读取cr05中断请求寄存器，按原因处理。
整体结构是一大个case语句
00001复位，则将内存中保存好的8位数字都清0
00010暂停按轮询处理，第2段处理其实没必要写。
00100 小时+1
01000 分钟+1
10000 秒钟+1

+1都是读内存相应位，+1处理之后放回去，然后eret